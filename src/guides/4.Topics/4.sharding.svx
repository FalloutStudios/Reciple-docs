---
title: Sharding
---
<script lang="ts">
    import Alert from '$lib/components/Alert.svelte';
</script>


# Sharding
Before we get started, please note that sharding is an advanced topic! Sharding is only required at 2,500 serversâ€”at that point, Discord will not allow your bot to login without sharding.

<Alert type='warning' title='WARNING'>
    This guide will only tackle the basics of sharding using Discord.js <a href="https://discordjs.dev/docs/packages/discord.js/main/ShardingManager:Class"><code>ShardingManager</code></a>.
</Alert>

## Sharding File
Your sharding file the file that manages your shards, rather than running your bot using `npm run start`. You will need to run your bot using the shard file we will create.

First, create a new file in your bot's root directory. In this case we will name it `sharding-manager.js`. After creating the file, we will hook Reciple args to the shard process.

```js
import { cli, command } from 'reciple';
import { config as loadEnv } from 'dotenv';

// Set the command args parser
Reflect.set(command, 'options', command.options.filter(o => !['shardmode', 'version', 'yes'].includes(o.name())));
command.name('').description('The options below are passed to reciple cli shards').parse();

// Change cwd to the cli's one
process.chdir(cli.cwd);

// Load env file
loadEnv({ path: cli.options.env });
```

Then, we will read the config file of the bot so we can get the logger configuration. This is important so every shard has separate logs.

```js
import { cli, command, ConfigReader } from 'reciple';
import { config as loadEnv } from 'dotenv';
import path from 'node:path';

// ...Previous Code Here...

// Read config file
const config = (await ConfigReader.readConfigJS(cli.options.config)).config;
const logsFolder = process.env.LOGS_FOLDER ?? path.join(process.cwd(), (config.logger.logToFile.logsFolder || 'logs'));
```

After the we can create the sharding manager's logger.

```js
import { cli, command, ConfigReader } from 'reciple';
import { config as loadEnv } from 'dotenv';
import path from 'node:path';

// ...Previous code here...

// Create the sharding manager's logger
const logger = await (await createLogger({
    debugmode: true,
    coloredMessages: true,
    shards: false
}))
.setDebugMode(true)
.setName('ShardManager')
.createFileWriteStream({
    file: path.join(logsFolder, `/sharder/${process.pid}/main.log`),
    renameOldFile: true
});

// Modify some env variables
Reflect.set(process.env, 'SHARDMODE', true);
Reflect.set(process.env, 'SHARDS_LOGS_FOLDER', path.join(logsFolder, `/sharder/${process.pid}`));
```

After setting up the command args, config, and logger. We will create the [`ShardingManager`](https://discordjs.dev/docs/packages/discord.js/main/ShardingManager:Class) that manages the shards.\

```js
import { cli, command, ConfigReader } from 'reciple';
import { config as loadEnv } from 'dotenv';
import { createReadStream } from 'node:fs';
import path from 'node:path';

// ...Previous code here...

// Create the sharding manager
const shards = new ShardingManager(cli.binPath, {
    shardArgs: ['--shardmode', ...process.argv.slice(2)],
    token: config.token,
    totalShards: 5,
    mode: 'process',
    respawn: true,
});
```

After creating the sharding manager, we will listen to the new shards to configure their individual logger.

```js
import { cli, command, ConfigReader } from 'reciple';
import { config as loadEnv } from 'dotenv';
import { createReadStream } from 'node:fs';
import path from 'node:path';

// ...Previous code here...

// Listen to new shards
shards.on('shardCreate', shard => {
    let logs;

    logger.log(`Creating shard ${shard.id}...`);

    shard.on('ready', () => {
        logger.log(`Shard ${shard.id} is ready!`);
        if (!logs) return;

        logger.log(`Logs for shard ${shard.id} is located at '${logs}'`);

        const readStream = createReadStream(logs, 'utf-8');

        readStream.on('data', data => logger.writeStream?.write(data.toString('utf-8')));
    });

    shard.on('reconnecting', () => logger.log(`Shard ${shard.id} is reconnecting!`));
    shard.on('disconnect', () => logger.log(`Shard ${shard.id} disconnected!`));
    shard.on('death', () => logger.log(`Shard ${shard.id} died!`));
    shard.on('error', err => logger.log(`Shard ${shard.id} encountered an error!\n`, err));

    shard.on('message', data => {
        if (!('type' in data) || data.type !== 'ProcessInfo') return;

        logs = data.log;
    });
});
```

Almost done, now we will listen to process exit so we can properly unload modules of shards that we created.
```js
import { cli, command, ConfigReader } from 'reciple';
import { config as loadEnv } from 'dotenv';
import { createReadStream } from 'node:fs';
import path from 'node:path';

// ...Previous code here...

// Listen to process exit signals
process.stdin.resume();

process.once('SIGHUP', stopProcess);
process.once('SIGINT', stopProcess);
process.once('SIGQUIT', stopProcess);
process.once('SIGABRT', stopProcess);
process.once('SIGALRM', stopProcess);
process.once('SIGTERM', stopProcess);
process.once('SIGBREAK', stopProcess);
process.once('SIGUSR2', stopProcess);

function stopProcess() {
    shards.shards.map(c => {
        logger.log(`Killed ${c.id}`);

        if (c.process) {
            c.process?.kill('SIGINT');
        } else {
            c.kill();
        }
    });

    logger.log(`Exitting process!`);
    setTimeout(() => process.exit(0), 500);
}
```

And finally, spawn the shards from the sharding manager and all done!
```js
import { cli, command, ConfigReader } from 'reciple';
import { config as loadEnv } from 'dotenv';
import { createReadStream } from 'node:fs';
import path from 'node:path';

// ...Previous code here...

// Spawn the shards
await shards.spawn();
```

You can now run your sharding manager by typing `node sharding-manager.js` in your terminal.

<Alert type='info' title='INFO'>
    Because we hooked the process args to the shard process, we can also use Reciple options when running shards, for example <code>node sharding-manager.js --token YOUR_TOKEN</code>
</Alert>
<Alert type='warning' title='WARNING'>
    Passing arguments to the shards is only available when the sharding mode is set to `process` instead of `worker`.
</Alert>

### Resulting Code
```js
import { cli, command, ConfigReader } from 'reciple';
import { config as loadEnv } from 'dotenv';
import { createReadStream } from 'node:fs';
import path from 'node:path';

// Set the command args parser
Reflect.set(command, 'options', command.options.filter(o => !['shardmode', 'version', 'yes'].includes(o.name())));
command.name('').description('The options below are passed to reciple cli shards').parse();

// Change cwd to the cli's one
process.chdir(cli.cwd);

// Load env file
loadEnv({ path: cli.options.env });

// Read config file
const config = (await ConfigReader.readConfigJS(cli.options.config)).config;
const logsFolder = process.env.LOGS_FOLDER ?? path.join(process.cwd(), (config.logger.logToFile.logsFolder || 'logs'));

// Create the sharding manager's logger
const logger = await (await createLogger({
    debugmode: true,
    coloredMessages: true,
    shards: false
}))
.setDebugMode(true)
.setName('ShardManager')
.createFileWriteStream({
    file: path.join(logsFolder, `/sharder/${process.pid}/main.log`),
    renameOldFile: true
});

// Modify some env variables
Reflect.set(process.env, 'SHARDMODE', true);
Reflect.set(process.env, 'SHARDS_LOGS_FOLDER', path.join(logsFolder, `/sharder/${process.pid}`));

// Create the sharding manager
const shards = new ShardingManager(cli.binPath, {
    shardArgs: ['--shardmode', ...process.argv.slice(2)],
    token: config.token,
    totalShards: 5,
    mode: 'process',
    respawn: true,
});

// Listen to new shards
shards.on('shardCreate', shard => {
    let logs;

    logger.log(`Creating shard ${shard.id}...`);

    shard.on('ready', () => {
        logger.log(`Shard ${shard.id} is ready!`);
        if (!logs) return;

        logger.log(`Logs for shard ${shard.id} is located at '${logs}'`);

        const readStream = createReadStream(logs, 'utf-8');

        readStream.on('data', data => logger.writeStream?.write(data.toString('utf-8')));
    });

    shard.on('reconnecting', () => logger.log(`Shard ${shard.id} is reconnecting!`));
    shard.on('disconnect', () => logger.log(`Shard ${shard.id} disconnected!`));
    shard.on('death', () => logger.log(`Shard ${shard.id} died!`));
    shard.on('error', err => logger.log(`Shard ${shard.id} encountered an error!\n`, err));

    shard.on('message', data => {
        if (!('type' in data) || data.type !== 'ProcessInfo') return;

        logs = data.log;
    });
});

// Listen to process exit signals
process.stdin.resume();

process.once('SIGHUP', stopProcess);
process.once('SIGINT', stopProcess);
process.once('SIGQUIT', stopProcess);
process.once('SIGABRT', stopProcess);
process.once('SIGALRM', stopProcess);
process.once('SIGTERM', stopProcess);
process.once('SIGBREAK', stopProcess);
process.once('SIGUSR2', stopProcess);

function stopProcess() {
    shards.shards.map(c => {
        logger.log(`Killed ${c.id}`);

        if (c.process) {
            c.process?.kill('SIGINT');
        } else {
            c.kill();
        }
    });

    logger.log(`Exitting process!`);
    setTimeout(() => process.exit(0), 500);
}

// Spawn the shards
await shards.spawn();
```